/*

    After a classification, there are a finite number of j-invariants of non-CM E/Q left to consider.
    We want to describe the subgroup of GL(2,Zhat) generated by the image of rho_E^* and the scalar matrices.

*/

load "FindOpenImage.m";
jinvariants:=[j: j in known_exceptional_jinvariants];
jinvariants:=Sort(jinvariants);  // j-invariants we need to consider

ExceptionalImages:=AssociativeArray(); // array to keep track of Galois image


for j in jinvariants do 
    
    // We first find a group G that may be too large (and X_G has finitely many points)
    b,k,G:=FindAgreeableClosure(j);  assert not b;
    
    N:=gl2Level(G);
    G:=ChangeRing(G,Integers(N));
    if IsOdd(N) then 
        G:=gl2Lift(G,2*N);  // we want to always consider the prime 2
    end if; 

end for;



function OpenMaximalSubgroups(G)
    /*
        Input:  
            Let G be a subgroup of GL(2,Z/N) that has full determinant and contains the scalar matrices.

        By lifting, we can view G as a subgroup of GL(2,Z_N).

        Output:
            Sequence of the maximal subgroups M of G in GL(2,Z_N), up to conjugation in GL(2,Z_N), such that
                - M has full determinant and contains scalar matrices,
                - M and G have same ell-adic projections for all ell dividing N

        Warning: this function is rather slow; that is why we don't use it for the main cases.
    */

    /* Idea behind function:  Assume N divisible by 4 if even.    Suppose M is one of the desired maximal subgroup
        of G.    Then M and G disagree modulo N*ell for some prime ell dividing N.
        [If M equals G modulo N*ell for all ell, then one shows that M contains all A in GL(2,Z_N) congruent to I modulo N]
        Moreover, one does not need to check the largest ell dividing N if it is at least 5.
    */

    max_subgroups:=[];  // sequence to keep tracks of maximal subgroups

    // Call our group G0 instead; need to make sure that its level is divisible by 4 if even.
    G0:=G;
    N0:=#BaseRing(G0);
    if N0 mod 4 eq 2 then
        N0:=N0*2;
        G0:=gl2Lift(G0,N0);
    end if;    
    
    ell_max:=Maximum(PrimeDivisors(N0));
    
    for ell in PrimeDivisors(N0) do
        if ell eq ell_max and ell_max ge 5 then 
            N:=N0;
        else
            N:=N0*ell;  
        end if;

        G:=gl2Lift(G0,N);
        PG,iota:=quo<G|Center(GL(2,Integers(N)))>;

        HH:=[ H`subgroup: H in MaximalSubgroups(PG)];
        HH:=[ H@@iota: H in HH];

        // Only want subgroups with full determinant and correct p-adic projections.
        for p in PrimeDivisors(N0) do
            Np:=p^Valuation(N,p);
            Gp:=ChangeRing(G,Integers(Np));
            HH:=[ H : H in HH | ChangeRing(H,Integers(Np)) eq Gp];
            HH:=[ H: H in HH | GL2DetIndex(H) eq 1];
        end for;

        max_subgroups:=max_subgroups cat HH;
    end for;

    max_subgroups:=[ ChangeRing(H,Integers(gl2Level(H))): H in max_subgroups];  // reduce groups mod their level

    // want to consider groups that are nonconjugate in GL(2,Z_N)
    groups:=[];
    for H in max_subgroups do
        b:= exists{H2: H2 in groups | #BaseRing(H) eq #BaseRing(H2) and IsConjugate(GL(2,BaseRing(H)),H,H2)};
        if not b then
            groups:=groups cat [H];
        end if;
    end for;

    return groups;
end function;





total_time:=Cputime();
for j in Keys(ExceptionalImages) do
    " ";
    print "j=",j;

    repeat

        G:=ExceptionalImages[j];  
        N:=#BaseRing(G);

        E:=EllipticCurveWithjInvariant(j);
        E:=MinimalTwist(E); 
        bad_primes:=Set(BadPrimes(E)) join {2,3} join Set(PrimeDivisors(N));

        subgroups:=OpenMaximalSubgroups(G);
        image_found:=true;
        for H in subgroups do
            N_:=LCM(#BaseRing(H),#BaseRing(G));
            G_:=gl2Lift(G,N_);
            H_:=gl2Lift(H,N_);
            assert H_ subset G_;
            trdetH:= { [Trace(C[3]),Determinant(C[3])] : C in ConjugacyClasses(H_) };
            trdetG:= { [Trace(C[3]),Determinant(C[3])] : C in ConjugacyClasses(G_) };
            trdetGdiffH := { [Trace(C[3]),Determinant(C[3])] : C in ConjugacyClasses(G_) | C[3] notin H_};
        
            p:=2;
            done:=false;
            splitting_primes:=[];
            while not done do
                repeat
                    p:=NextPrime(p);
                until p notin bad_primes;
                td:=[Integers(N_)!TraceOfFrobenius(E,p), Integers(N_)!p];
                if td notin trdetH then   // this means Frob_p not in H
                    done:=true;
                    "done";
                end if;

                if td notin trdetGdiffH then  // this means Frob_p in H
                    splitting_primes:=splitting_primes cat [p];
                end if;

                if p ge 30000 and Index(G_,H_) eq 2 then
                    dd:=&*PrimeDivisors(N_*&*BadPrimes(E));
                    D:={d: d in Divisors(dd) | d ne 1} join {-d: d in Divisors(dd)};
                    D;
                    D:=[* KroneckerCharacter(d): d in D *];

                    D:=[* chi: chi in D | &and[ chi(p) eq 1 : p in splitting_primes] *];

                    "Found smaller group";
                    G_new:=ChangeRing(H_,Integers(gl2Level(H_)));
                    ExceptionalImages[j]:=G_new;
                    if #D ne 0 then 
                        "Warning: have candidate only; need to check directly";
                    end if;
                    
                    done:=true;

                elif p ge 30000 then 
                    "===This case should not occur!===";
                     assert false;  
                end if;

            end while;

            // WARNING: no longer recurses!!


end for;


// Write modular curves to a file.
I:=Open("data-files/exceptional-images.dat", "w");
for k in Keys(X) do
	y:=X[k];
    WriteObject(I, y);
end for;


/*

// 7, 13, 16, 28, 32, 38, 43
for i in {7,13,16,28,32,38,43} do //[1..#jinvariants] do
    " ";
    print "i=",i;

    j:=jinvariants[i];
    E:=EllipticCurveWithjInvariant(j);
    E:=MinimalTwist(E);    

    b,k,G:=FindAgreeableClosure(j);
    //if k notin Keys(X) then continue j; end if;
    N:=gl2Level(G);
    G:=ChangeRing(G,Integers(N));
    

    bad_primes:=Set(BadPrimes(E)) join {2,3} join Set(PrimeDivisors(N));

    k;Factorization(N);
    //FindCommutatorSubgroup(G);
    subgroups:=ExplicitGoursatSubgroups(G);
    #subgroups;
    for H in subgroups do

        N_:=#BaseRing(H);
        G_:=gl2Lift(G,N_);
        assert H subset G_;

        trdetH:= { [Trace(C[3]),Determinant(C[3])] : C in ConjugacyClasses(H) };
        trdetG:= { [Trace(C[3]),Determinant(C[3])] : C in ConjugacyClasses(G_) };
        trdetGdiffH := { [Trace(C[3]),Determinant(C[3])] : C in ConjugacyClasses(G_) | C[3] notin H};
    
        p:=2;
        done:=false;
        while not done do
            repeat
                p:=NextPrime(p);
            until p notin bad_primes;

            td:=[Integers(N_)!TraceOfFrobenius(E,p), Integers(N_)!p];

            if td notin trdetH then
                done:=true;
                "done";
            end if;

            if td notin trdetGdiffH then
                assert true; //
            end if;
            


            if p ge 20000 then 
                "======";
                trdetG diff trdetH;
                print "i=",i;
                print "index=", #G_/#H;
                j;
                N_;
                [Eltseq(a):a in Generators(H)];
                
                E;
                assert false;  
            end if;
        end while;

    end for;
    //[Index(gl2Lift(G,#BaseRing(H)),H): H in ExplicitGoursatSubgroups(G)];

end for;

Cputime(total_time);

/*

function ExplicitGoursat(G1,G2)
    // contain centers...
    assert IsSolvable(G1) and IsSolvable(G2);

    N1:=#BaseRing(G1);
    N2:=#BaseRing(G2);
    assert GCD(N1,N2) eq 1;
    N:=N1*N2;

    G1_lift:=gl2Lift(G1,N);
    G2_lift:=gl2Lift(G2,N);
    G:=G1_lift meet G2_lift;
    PG,iota:=quo<G|Center(GL(2,Integers(N)))>;

    for p in PrimeDivisors(GCD(#G1 div EulerPhi(N1),#G2 div EulerPhi(N2))) do
        HH:=[H`subgroup: H in Subgroups(PG:OrderEqual:=#PG div p)];
        HH:=[ H@@iota: H in HH];
        HH:=[ H : H in HH | ChangeRing(H,Integers(N1)) eq G1 and ChangeRing(H,Integers(N2)) eq G2];
        HH:=[ H: H in HH | GL2DetIndex(H) eq 1];
    end for;


    return #HH;
end function;


for j in known_exceptional_jinvariants do
    b,k,G:=FindAgreeableClosure(j);
    //if k notin Keys(X) then continue j; end if;
    N:=gl2Level(G);
    G:=ChangeRing(G,Integers(N));
        
        N:=#BaseRing(G);
        GL2:=GL(2,Integers(N));
        Z:=Center(GL2);
        assert Z subset G;
        Q,iota:=quo<G|Z>;
        if #Q mod 2 eq 0 then
            HH:=[H`subgroup: H in Subgroups(Q:OrderEqual:=#Q div 2)];
            HH:=[ H@@iota: H in HH];
            HH:=[ H: H in HH | GL2DetIndex(H) eq 1];
            [N,#HH];
        end if;

end for;



/*
for j in known_exceptional_jinvariants do
    b,k,G:=FindAgreeableClosure(j);
    //if k notin Keys(X) then continue j; end if;
    N:=gl2Level(G);
    G:=ChangeRing(G,Integers(N));
        
        N:=#BaseRing(G);
        GL2:=GL(2,Integers(N));
        Z:=Center(GL2);
        assert Z subset G;
        Q,iota:=quo<G|Z>;
        if #Q mod 2 eq 0 then
            HH:=[H`subgroup: H in Subgroups(Q:OrderEqual:=#Q div 2)];
            HH:=[ H@@iota: H in HH];
            HH:=[ H: H in HH | GL2DetIndex(H) eq 1];
            [N,#HH];
        end if;

end for;
*/

